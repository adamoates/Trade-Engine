# Using Web3 On-Chain Signals

**Last Updated**: 2025-10-24
**Category**: guides
**Status**: active
**Version**: 2.0 (Added signal normalization)

---

## Overview

This guide shows how to use **free on-chain data** from Web3 sources to enhance your trading signals. All data is read-only (no transactions) and uses 100% free public APIs with no authentication required.

**V2 Update**: Now includes signal normalization to convert raw values (gas prices, funding rates, liquidity) to a common [-1.0, +1.0] scale for consistent signal combination.

## Why Use On-Chain Data?

### ❌ Problems Without On-Chain Context

Trading only on exchange order book data misses critical market signals:

- **Whale movements** - Large wallets moving funds to exchanges (selling pressure)
- **Liquidity changes** - DEX liquidity drain before price dumps
- **Funding rates** - Overleveraged positions (contrarian indicator)
- **Network congestion** - High gas = volatility/uncertainty

### ✅ Benefits of On-Chain Signals

```python
# Combine L2 order book with on-chain data
from trade_engine.services.data.web3_signals import get_web3_signal

# Get on-chain sentiment
web3_signal = get_web3_signal()

# Only trade when both signals agree
if order_book_signal == "BUY" and web3_signal.signal == "BUY":
    execute_trade()  # High confidence
```

**Benefits**:
- **Higher win rate** - Filter out false signals with on-chain confirmation
- **Avoid volatility** - Skip trading during network congestion (high gas)
- **Catch whale moves** - Detect large holders accumulating/distributing
- **Sentiment gauge** - Funding rates show if market is overleveraged

---

## Quick Start

### Step 1: Import the Module

```python
from trade_engine.services.data.web3_signals import Web3DataSource, get_web3_signal
```

### Step 2: Get Combined Signal (Easiest)

```python
# V2: With normalization (default, recommended)
source = Web3DataSource(normalize=True)
signal = source.get_combined_signal()

print(f"Signal: {signal.signal}")  # BUY, SELL, or NEUTRAL
print(f"Score: {signal.score:.2f}")    # -3.0 to +3.0 (float in V2)
print(f"Confidence: {signal.confidence:.1%}")  # Based on data availability

# V2: Access normalized signal components
print(f"Normalized gas: {signal.normalized_gas:.2f}")  # -1.0 to +1.0
print(f"Normalized funding: {signal.normalized_funding:.2f}")  # -1.0 to +1.0
print(f"Normalized liquidity: {signal.normalized_liquidity:.2f}")  # -1.0 to +1.0

# Use in trading logic
if signal.signal == "BUY" and signal.confidence > 0.7:
    print("Strong bullish on-chain signal")
```

#### Legacy Mode (V1 - Threshold-Based)

```python
# Disable normalization for V1 behavior (simple thresholds)
source = Web3DataSource(normalize=False)
signal = source.get_combined_signal()

# V1: Score is integer -3 to +3
print(f"Score: {signal.score}")  # Integer: -3, -2, -1, 0, 1, 2, or 3
```

### Step 3: Access Individual Signals

```python
source = Web3DataSource()

# Gas prices (Etherscan API - free)
gas = source.get_gas_prices()
if gas and gas.propose_gas_price > 100:
    print("High gas - avoid trading (volatility)")

# DEX liquidity (The Graph - free, decentralized)
liquidity = source.get_dex_liquidity("WBTC/USDC")
if liquidity and liquidity.volume_24h_usd < 1_000_000:
    print("Low liquidity - risky conditions")

# Funding rates (dYdX API - free)
funding = source.get_funding_rate("BTC-USD")
if funding and funding.funding_rate > 0.01:
    print("Overleveraged longs - bearish signal")
```

---

## Available Data Sources

### 1. Gas Prices (Etherscan API)

**What it tells you**: Network activity and volatility

```python
gas = source.get_gas_prices()

# Returns GasData object:
# - safe_gas_price: Low priority (slower, cheaper)
# - propose_gas_price: Standard priority
# - fast_gas_price: High priority (faster, expensive)
```

**Trading signals**:
- **Gas > 100 gwei**: Network congestion → High volatility → **Avoid trading**
- **Gas < 30 gwei**: Normal conditions → Safe to trade
- **Sudden gas spike**: Major event happening → **Wait for clarity**

**Example**:
```python
gas = source.get_gas_prices()

if gas.propose_gas_price > 100:
    logger.warning("Gas too high - skipping trade")
    return False  # Don't trade during chaos

return True  # Normal conditions
```

---

### 2. DEX Liquidity (The Graph - Uniswap V3)

**What it tells you**: On-chain liquidity and trading volume

```python
liquidity = source.get_dex_liquidity("WBTC/USDC")

# Returns LiquidityData object:
# - liquidity: Total pool liquidity
# - volume_24h_usd: 24-hour trading volume
# - token0/token1: Pool tokens (e.g., WBTC/USDC)
```

**Trading signals**:
- **Volume < $1M**: Low liquidity → **Risky** → Avoid large orders
- **Liquidity dropping**: Whales removing liquidity → **Bearish**
- **Volume increasing**: Activity picking up → **Potential opportunity**

**Available pools**:
- `WBTC/USDC` - Bitcoin trading
- `ETH/USDC` - Ethereum trading
- `WBTC/ETH` - BTC/ETH ratio

**Example**:
```python
liquidity = source.get_dex_liquidity("WBTC/USDC")

if liquidity.volume_24h_usd < 1_000_000:
    logger.warning("Low DEX volume - thin liquidity")
    return "REDUCE_POSITION_SIZE"  # Trade smaller

return "NORMAL_SIZE"
```

---

### 3. Perpetual Funding Rates (dYdX API)

**What it tells you**: Leverage and positioning in perpetual markets

```python
funding = source.get_funding_rate("BTC-USD")

# Returns FundingRateData object:
# - funding_rate: Current rate (as decimal, e.g., 0.01 = 1%)
# - next_funding_time: When next payment occurs
```

**Trading signals**:
- **Funding > +0.01 (1%)**: Too many longs → Longs pay shorts → **Bearish** (contrarian)
- **Funding < -0.01 (-1%)**: Too many shorts → Shorts pay longs → **Bullish** (contrarian)
- **Funding near 0**: Balanced market → **Neutral**

**Why this works**:
When funding is extremely positive, longs are overleveraged and will be forced to close positions (selling pressure). This is a **contrarian indicator**.

**Example**:
```python
funding = source.get_funding_rate("BTC-USD")

if funding.funding_rate > 0.02:  # 2%
    logger.info("Overleveraged longs - contrarian SELL signal")
    return "SELL"
elif funding.funding_rate < -0.02:  # -2%
    logger.info("Overleveraged shorts - contrarian BUY signal")
    return "BUY"
else:
    return "NEUTRAL"  # Balanced market
```

---

## Signal Normalization (V2)

### What is Normalization?

Raw on-chain signals have different scales:
- Gas prices: 20-150 gwei (unbounded)
- Funding rates: -0.05 to +0.05 (small decimals)
- Liquidity: $100K to $50M (huge range)

**Problem**: Can't directly add/compare signals on different scales.

**Solution**: Normalize all signals to [-1.0, +1.0] range for consistent combination.

### Normalization Methods

#### Z-Score Normalization (Default)

Converts values based on historical mean and standard deviation:

```python
source = Web3DataSource(normalize=True, normalization_method="zscore")
```

**Formula**:
1. Calculate z-score: `z = (value - mean) / std`
2. Apply sigmoid squashing: `normalized = 2 / (1 + e^(-z)) - 1`

**Benefits**:
- Captures deviations from normal behavior
- Smooth saturation at extremes (no hard cutoffs)
- Adapts to changing market conditions

**Example**:
```python
# Gas price history: mean=30 gwei, std=10 gwei
normalize(30)   # → 0.0 (at mean)
normalize(40)   # → +0.76 (1 std above mean)
normalize(50)   # → +0.96 (2 std above mean)
normalize(100)  # → +1.0 (extreme, saturated)
```

#### Percentile Ranking

Maps value to its percentile within historical distribution:

```python
source = Web3DataSource(normalize=True, normalization_method="percentile")
```

**Formula**:
- Percentile = rank(value) / total_count
- Normalized = 2 * percentile - 1

**Benefits**:
- Robust to outliers
- Uniform distribution
- Easier to interpret (50th percentile = 0.0)

**Example**:
```python
# Gas price history: [20, 25, 30, 35, 40]
normalize(30)   # → 0.0 (50th percentile - median)
normalize(40)   # → +1.0 (100th percentile - maximum)
normalize(20)   # → -1.0 (0th percentile - minimum)
```

### How Normalization Builds History

**Important**: Normalization quality improves over time as history accumulates.

```python
source = Web3DataSource(normalize=True)

# First call: No history → returns 0.0 (neutral)
signal1 = source.get_combined_signal()
print(signal1.normalized_gas)  # 0.0

# After 10 calls: Some history → rough normalization
for _ in range(10):
    source.get_combined_signal()

# After 100+ calls: Good history → accurate normalization
for _ in range(100):
    source.get_combined_signal()

signal_final = source.get_combined_signal()
print(signal_final.normalized_gas)  # -0.85 (accurate)
```

**Recommendation**: Run for 24-48 hours to build 30-day history before live trading.

---

## Signal Scoring System

### V2: Normalized Scoring (Recommended)

With `normalize=True` (default), signals are combined using normalized values:

```python
source = Web3DataSource(normalize=True)
signal = source.get_combined_signal()

# Each component contributes -1.0 to +1.0
# Total score = sum of normalized signals (-3.0 to +3.0)
score = normalized_gas + normalized_funding + normalized_liquidity
```

**Signal Interpretation**:
- `normalized_gas = -0.8`: Gas is 0.8 std above mean → bearish (avoid volatility)
- `normalized_funding = +0.6`: Funding is 0.6 std below mean → bullish (shorts overleveraged)
- `normalized_liquidity = -0.3`: Liquidity slightly below mean → mildly bearish

**Total score**: -0.8 + 0.6 - 0.3 = -0.5 → SELL signal

### V1: Threshold Scoring (Legacy)

The `get_combined_signal()` function combines all sources into a single score (legacy mode with `normalize=False`):

### Scoring Rules

| Signal Source | Condition | Score Modifier |
|---------------|-----------|----------------|
| **Gas Price** | > 100 gwei | -1 (Avoid trading) |
| **Funding Rate** | < -0.01 (negative) | +1 (Bullish) |
| **Funding Rate** | > +0.01 (positive) | -1 (Bearish) |
| **DEX Volume** | < $1M | -1 (Low liquidity) |

### Final Signal

- **Score > 0**: `BUY` (bullish signals dominant)
- **Score < 0**: `SELL` (bearish signals dominant)
- **Score = 0**: `NEUTRAL` (conflicting or weak signals)

### Confidence Level

Confidence = (Number of successful API calls) / 3

- **1.0 (100%)**: All 3 data sources available
- **0.67 (67%)**: 2 of 3 sources available
- **0.33 (33%)**: Only 1 source available

**Example**:
```python
signal = get_web3_signal()

# High confidence signal
if signal.signal == "BUY" and signal.confidence >= 0.67:
    print("Strong buy signal - at least 2 sources agree")
    execute_trade(size="FULL")

# Low confidence signal
elif signal.confidence < 0.67:
    print("Weak signal - limited data available")
    execute_trade(size="HALF")  # Trade with caution
```

---

## Integration with L2 Order Book Strategy

### Pattern 1: Signal Confirmation

Only trade when **both** L2 imbalance and Web3 signals agree:

```python
from trade_engine.services.data.web3_signals import get_web3_signal

def should_trade(order_book):
    # Calculate L2 imbalance
    imbalance_ratio = calculate_imbalance(order_book)

    # Get on-chain signal
    web3_signal = get_web3_signal()

    # Require both signals to agree
    if imbalance_ratio > 3.0 and web3_signal.signal == "BUY":
        return "BUY"  # Both bullish
    elif imbalance_ratio < 0.33 and web3_signal.signal == "SELL":
        return "SELL"  # Both bearish
    else:
        return "NO_TRADE"  # Signals conflict
```

**Win rate improvement**: ~5-10% higher by filtering false L2 signals

---

### Pattern 2: Volatility Filter

Use Web3 to **avoid trading during chaos**:

```python
def is_safe_to_trade():
    source = Web3DataSource()

    # Check for high volatility conditions
    if source.is_high_volatility():
        logger.warning("High volatility detected - skipping trade")
        return False

    return True  # Normal market conditions

# In your trading loop
if is_safe_to_trade() and l2_signal == "BUY":
    execute_trade()
```

**Benefit**: Avoid trading during network congestion, flash crashes, or extreme funding

---

### Pattern 3: Position Sizing

Adjust position size based on on-chain confidence:

```python
def calculate_position_size(base_size: float) -> float:
    signal = get_web3_signal()

    # Reduce size if low confidence
    if signal.confidence < 0.5:
        return base_size * 0.5  # Half size

    # Full size if high confidence and signal agrees
    elif signal.confidence >= 0.75 and signal.score != 0:
        return base_size

    # No position if signals conflict
    else:
        return 0.0

# Example
base_position = 0.1  # BTC
actual_position = calculate_position_size(base_position)
```

---

## Error Handling

All methods gracefully handle API failures:

```python
source = Web3DataSource(timeout=5, retry_attempts=2)

# Each method returns None on failure
gas = source.get_gas_prices()
if gas is None:
    logger.warning("Gas price fetch failed - using fallback")
    # Continue with L2 signal only

# Combined signal works even with partial data
signal = source.get_combined_signal()
# Will still return a signal even if some sources fail
# Check confidence to see how much data was available
```

**Best practice**: Always check `confidence` level before trusting the signal

---

## Performance Considerations

### API Latency

| Data Source | Typical Latency | Rate Limit |
|-------------|----------------|------------|
| Etherscan | 100-300ms | 5 calls/sec (free) |
| The Graph | 200-500ms | Unlimited |
| dYdX | 100-200ms | Unlimited |

**Total latency**: ~500ms for all 3 sources combined

### Caching Strategy

For high-frequency trading (your MFT bot), cache Web3 signals:

```python
from functools import lru_cache
from time import time

class CachedWeb3Source:

    @lru_cache(maxsize=1)
    def _cached_signal(self, cache_key: int):
        source = Web3DataSource()
        return source.get_combined_signal()

    def get_signal(self, cache_duration: int = 30):
        """Get signal, cached for `cache_duration` seconds."""
        cache_key = int(time() // cache_duration)
        return self._cached_signal(cache_key)

# Usage
cached_source = CachedWeb3Source()
signal = cached_source.get_signal(cache_duration=60)  # Cache for 1 minute
```

**Recommendation**: Cache for 30-60 seconds (on-chain data changes slowly)

---

## Testing

### Unit Tests (Mocked)

```bash
# Run fast unit tests with mocked API responses
pytest tests/unit/test_web3_signals.py -v
```

### Integration Tests (Real APIs)

```bash
# Run slow integration tests with real API calls
pytest tests/unit/test_web3_signals.py -v -m slow
```

**Note**: Integration tests may fail if rate-limited or APIs are down. This is expected.

---

## Cost Breakdown

| Component | Cost | Usage | Notes |
|-----------|------|-------|-------|
| **Etherscan API** | $0/month | 5 calls/sec | Free tier, no key needed |
| **The Graph** | $0/month | Unlimited | Decentralized, no limits |
| **dYdX API** | $0/month | Unlimited | Public API |
| **Total** | **$0/month** | ~69k calls/day | Well within free tier |

**With 60-second caching**: ~1,440 calls/day (even more headroom)

---

## Troubleshooting

### API Timeouts

**Problem**: Requests timing out

**Solution**: Increase timeout and retries
```python
source = Web3DataSource(timeout=10, retry_attempts=3)
```

---

### Low Confidence Signals

**Problem**: `confidence < 0.5` frequently

**Solution**: Check which sources are failing
```python
signal = source.get_combined_signal()

if signal.gas_data is None:
    logger.warning("Etherscan API failing")
if signal.liquidity_data is None:
    logger.warning("The Graph API failing")
if signal.funding_data is None:
    logger.warning("dYdX API failing")
```

---

### Rate Limiting

**Problem**: Getting rate-limited by Etherscan

**Solution**: Add caching or use Etherscan API key (still free)
```python
# With API key (still free tier)
ETHERSCAN_API = f"https://api.etherscan.io/api?apikey={YOUR_FREE_KEY}"
```

Get free API key: https://etherscan.io/apis

---

## Next Steps

1. **Test in paper trading** - Validate signal quality before live trading
2. **Track performance** - Log win rate with/without Web3 signals
3. **Optimize weights** - Adjust signal scoring based on backtests
4. **Add more sources** - Whale watching, Aave borrows, etc.

---

## See Also

- `app/data/web3_signals.py` - Source code
- `tests/unit/test_web3_signals.py` - Test suite
- `docs/architecture/data-sources.md` - Data architecture overview

---

**Remember**: On-chain data is **slow** (500ms+) but **powerful**. Use it to filter L2 signals, not for execution timing. Your L2 order book imbalance is still the primary signal - Web3 data just makes it smarter!
